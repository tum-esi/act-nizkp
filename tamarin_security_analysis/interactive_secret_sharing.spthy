theory interactive_secret_sharing
begin

builtins: bilinear-pairing, hashing

// Functions for the ZK Proof and functions for the MAC Tag
functions: schnorrZKProof/3, multp/1, genSharedKey/2

// Generate Public and Private Key pair
rule generate_KeyPair:
	[ Fr(~skA) ]
    --[ HonestKey($A, ~skA) ]->
	[ !SecretKey($A, ~skA), !PubKey($A, multp(~skA)) ]

// Rule to output a public key of A or B
rule get_pubKey:
	[ !PubKey($A, multp(skA)) ]
    -->
	[ Out(multp(skA)) ]
	
// Rule to reveal the secret key to the adversary
rule reveal_secretKey:
	[ !SecretKey($A, skA) ]
    --[ RevealSecret($A) ]->
	[ Out(skA) ]


// Protocol Init for A and B
rule InitA:
	[ 
        Fr(~id),
	    !SecretKey($A, skA),
        !PubKey($A, multp(skA))
	]
    --[ 
        InitA(),
        CreateA($A, ~id),
        KnowsWitness($A, skA)
    ]->
	[ AState1($A, ~id, skA, multp(skA)) ]
  
rule InitB:
	[ 
        Fr(~id),
        !SecretKey($B, skB),
        !PubKey($B, multp(skB))
    ]
    --[
        InitB(),
        CreateB($B, ~id) 
    ]->
	[ BState1($B, ~id, skB, multp(skB)) ]


// A sends commitment to B
rule ACommitsToB:
    let
        R_A = multp(~r_A)
    in
    [
        Fr(~r_A),
        AState1(A, id, skA, multp(skA))
    ]
    --[
        ACreatedCommitmentToB(A, R_A)
    ]->
    [
        AState2(A, id, skA, multp(skA), ~r_A, R_A),
        Out(R_A)
    ]


// B sends commitment and challenge to A
rule BCommitsAndChallengesA:
    let
        R_B = multp(~r_B)
    in
    [
        Fr(~r_B),
        Fr(~c_B),
        BState1(B, id, skB, multp(skB)),
        In(R_A)
    ]
    --[ BCreatedCommitmentAndChallengeToA(B, R_B, ~c_B) ]->
    [
        BState2(B, id, skB, multp(skB), ~r_B, R_B, ~c_B, R_A),
        Out(<R_B, ~c_B>)
    ]

// A sends challenge and response to B
rule AChallengesAndRespondsB:
    let
        proof_A = schnorrZKProof(skA, rr_A, c_B)
    in
    [
        Fr(~c_A),
        AState2(A, id, skA, multp(skA), rr_A, R_A),
        In(<R_B, c_B>)
    ]
    --[ ACreatedProofForWitnessAndChallengesB(A, skA, ~c_A) ]->
    [
        AState3(A, id, rr_A, ~c_A, R_B),
        Out(<proof_A, ~c_A>)
    ]

// B verifies A's responds, calculates shared secret key and sends responds to A
rule BVerifyAndRespondsA:
    let
        proof_B = schnorrZKProof(skB, rr_B, c_A)
    in
    [
        BState2(B, id, skB, multp(skB), rr_B, R_B, c_B, R_A),
        !PubKey($A, APK),
        In(<proof_A, c_A>)
    ]
    --[
        BReceivedZKP(B, id, proof_A, APK, R_A, c_B),
        ValidSchnorrZKP(proof_A, APK, R_A, c_B),
        BVerifiedProof(B, id, proof_A, APK, R_A, c_B),
        BVerifiedAsProofAndBCreatedProofForWitness(B, proof_A, skB),
        SharedSecretKey(B, $A, genSharedKey(rr_B, R_A))
    ]->
    [ Out(proof_B) ]

// A verifies B's response and calculates shared secret key
rule AVerifyB:
    [
        AState3(A, id, rr_A, c_A, R_B),
        !PubKey($B, BPK),
        In(proof_B)
    ]
    --[
        AReceivedZKP(A, id, proof_B, BPK, R_B, c_A),
        ValidSchnorrZKP(proof_B, BPK, R_B, c_A),
        AVerifiedBsProof(A, proof_B),
        SharedSecretKey(A, $B, genSharedKey(rr_A, R_B)),
        Finish(A, id)
    ]->
    []


// Restrictions    
// This restriction is for verifying the Zero-Knowledge Proof
restriction IsValidZkp:
  "
    All #i w r cl cr pkey R. ValidSchnorrZKP(schnorrZKProof(w, r, cl), pkey, R, cr)@i
      ==> (Ex m n. pkey = multp(m) & R = multp(n) & m = w & n = r & cl = cr)
  "


// Lemmas
// Protocol is executable
lemma executable:
    exists-trace
        "
            // A ZKP of an honest key can be verified
            (
                Ex A B #i1 #i2 #i3 #i4 #i5 #i6 #i7 skA skB R_A R_B c_A c_B Aproof Bproof.
                HonestKey(A, skA)@i1 & HonestKey(B, skB)@i2 &
                ACreatedCommitmentToB(A, R_A)@i3 &
                BCreatedCommitmentAndChallengeToA(B, R_B, c_B)@i4 &
                ACreatedProofForWitnessAndChallengesB(A, skA, c_A)@i5 &
                BVerifiedAsProofAndBCreatedProofForWitness(B, Aproof, skB)@i6 &
                AVerifiedBsProof(A, Bproof)@i7 &
                i1 < i3 & i2 < i3 & i3 < i4 & i4 < i5 & i5 < i6 & i6 < i7
            ) &

            // Both A and B are only initiated once
            ( All #i #j. InitA()@i & InitA()@j ==> #i = #j ) &
            ( All #i #j. InitB()@i & InitB()@j ==> #i = #j ) &

            // Protocol is executed between two parties
            ( Ex A B idA idB #i #j. CreateA(A, idA)@i & CreateB(B, idB)@j & not A=B ) &

            // The secret key of A was not compromised
            not ( Ex A idA #i #j. CreateA(A, idA)@i & RevealSecret(A)@j ) &

            // The secret key of B was not compromised
            not ( Ex B idB #i #j. CreateB(B, idB)@i & RevealSecret(B)@j ) &

            // The shared secret key between A and B was not compromised
            not ( 
                    Ex A B shared_secret_key #i #j #k.
                    SharedSecretKey(A, B, shared_secret_key) @ #i &
                    SharedSecretKey(B, A, shared_secret_key) @ #j &
                    #j < #i &
                    K(shared_secret_key) @k
                )
        "


// Secrecy of the secret keys of both A and B
lemma secret_keys_secrecy:
  "
    not(
        Ex A B skA skB c_A zkproof_A #i1 #i2 #i3 #i4.
        ACreatedProofForWitnessAndChallengesB(A, skA, c_A)@i1 &
        BVerifiedAsProofAndBCreatedProofForWitness(B, zkproof_A, skB) @i2 &
        not(A = B) &
        K(skA)@i3 & K(skB) @i4 &
        not (Ex #i #j. RevealSecret(A)@i & RevealSecret(B)@j)
    )
  "

// Adversary cannot reveal the shared secret key
lemma shared_key_secrecy:
    "
    All A B shared_secret_key #i #j.
        (
            SharedSecretKey(A, B, shared_secret_key) @ #i &
            SharedSecretKey(B, A, shared_secret_key) @ #j &
            #j < #i &
            not(A = B)
        )
        ==> not(Ex #k . K(shared_secret_key) @ #k)
    "

end
